using UnityEngine;
using UnityEngine.UI;
using Mirror;

public class FieldCard : Entity
{
    [SyncVar/*, HideInInspector*/] public CardInfo card; // Get card info

    [Header("Card Properties")]
    public Image image; // card image on field
    public Text cardName; // Text of the card name
    public Text AbilityText; 
    public Text SecurityCheckText; 
    public Text DPbuffText;
    public Text isRestText;

    public bool giveBuff = false; // 1회용 버프 썼는가?(스펠카드용)

    [Header("Shine")]
    public Image shine;
    public Color hoverColor;
    public Color readyColor; // Shine color when ready to attack
    public Color targetColor; // Shine color when ready to attack

    [Header("Card Hover")]
    public HandCard cardHover;

    [Header("Owner")]
    [SyncVar]
    public Player player;

    [Header("Evo Route")]
    public FieldCard upperCard;
    public FieldCard underCard;
    public bool isUpperMostCard => upperCard == null; // 최상단 카드인가?
    public bool isUnderMostCard => underCard == null; // 최하단 카드인가?

    [Header("Security")]
    [SyncVar]public bool isSecurity = false;
    [Header("SpellEffect")]
    readonly public SyncList<Buffs> buffs = new SyncList<Buffs>(); // 효과 받은 수치를 저장해 두기
    public Buffs tempBuff;//텍스트 시각효과를 위해 받아놓을 버프 변수

    [Header("Buffs")]
    [SyncVar] public int securityAttack = 0;
    [Header("Test")]
    public FieldCardHover cardDragHover;

    // Update is called once per frame
    public override void Update()
    {
        base.Update();
        // If we have a card but no sprite, make sure the sprite is up to date since we can't SyncVar the sprite.
        // Useful to avoid bugs when a player was offline when the card spawned, or if they reconnected.
        if (image.sprite == null && (card.name != null || cardName.text == ""))
        {
            // Update Stats
            image.color = Color.white;
            image.sprite = card.image;

            //cardName.text = card.name; //터진다~

            // Update card hover info
            cardHover.UpdateFieldCardInfo(card);
        }

        //healthText.text = health.ToString();
        //strengthText.text = strength.ToString();

        if (CanAttack()) shine.color = readyColor;
        else if (CantAttack()) shine.color = Color.clear;

        ChaseUpperCard();

        //최상단 카드가 아니면 콜리전끄기test
        //if(isUpperMostCard==false) { GetComponent<BoxCollider2D>().enabled = false; }
        //else { GetComponent<BoxCollider2D>().enabled = true; }

        if (player==Player.localPlayer && casterType==Target.MY_BABY && cardDragHover!=null /*&& waitTurn <= 0*/)
        {
            if (Player.gameManager.isOurTurn && Player.localPlayer.enemyInfo.data.isTargeting==false)
            {
                cardDragHover.canDrag = true; //player.deck.CanPlayCard(manaCost); //원래는 마나 총량 넘으면 못내게 했는데 ECost라는 다른 루트땜에 일단 낼 수 있게함
            }
        }
    }

    [Command(requiresAuthority = false)]
    public void CmdUpdateWaitTurn()
    {
        //Debug.LogError("Here");
        if (waitTurn > 0) { waitTurn--; }
    }

    public void ChaseUpperCard()
    {
        if(isUpperMostCard==false && upperCard!=null && !cardDragHover.isDragging)//맨 위 카드가 아니고 위 카드 정보가 null이 아니라면
        {
            // 상대편에서 내 카드 볼때 메모리체커에 가려짐 반대로 해야할듯
            //GetComponent<RectTransform>().anchoredPosition = upperCard.GetComponent<RectTransform>().anchoredPosition + new Vector2(0, -47); 
            upperCard.GetComponent<RectTransform>().anchoredPosition = GetComponent<RectTransform>().anchoredPosition + new Vector2(0, 47);
        }
    }

    [Command(requiresAuthority = false)]
    public void CmdDestroySpellCard()
    {
        if (card.data is SpellCard spellCard && isTargeting == false)
        {
            //player.deck.playerField.Remove(card);//안씀
            //player.deck.graveyard.Add(card);//카드를 꺼내자마자 무덤에 저장되야함
            spellCard.EndTurnEffect(player);
            Destroy(this.gameObject);
        }
    }

    [Command(requiresAuthority = false)]
    public void CmdChangeSomeThing(Buffs buff, bool isStart)
    {
        if(isStart)
        {
            //isStart는 버프를 추가할 때인지 뺄 때인지 구분용
            if (buff.isFix)
            {
                //해당 버프가 고정값을 주면
                strength = buff.buffDP;
                //strength += -((CreatureCard)card.data).strength + buff.buffDP;
            }
            else
            {
                //해당 버프가 더하는 값이면
                strength += buff.buffDP;
                securityAttack += buff.securityAttack;
                waitTurn += buff.waitTurn;
            }

            if(strength <= 0)
            {
                //공깎 디버프로 최종 DP가 0이하가 되면 소멸
                IsDead = true;
                player.deck.graveyard.Add(this.card);
                Destroy(this.gameObject);
            }

            if(buff.breakEvo)
            {
                //진화원 퇴화면 이쪽으로
                CmdRemoveEvo(buff.removeEvoCount);
            }

            RpcTextSetActive(buff, isStart);
        }
        else
        {
            if(buff.isFix)
            {
                strength = ((CreatureCard)card.data).strength;
            }
            else
            {
                tempBuff.buffDP -= buff.buffDP;
                strength -= buff.buffDP;
            }
            securityAttack = 0;

            
            tempBuff.securityAttack = 0;

            if (tempBuff.buffDP != 0)
            {
                DPbuffText.gameObject.SetActive(true);
                DPbuffText.text = "DP + " + tempBuff.buffDP.ToString();
            }
            else
            {
                DPbuffText.gameObject.SetActive(false);
            }
            RpcTextSetActive(buff, isStart);
        }
    }

    [Command(requiresAuthority = false)]
    public void CmdAddBuff(Buffs buff)
    {
        buffs.Add(buff);
    }
    [Command(requiresAuthority = false)]
    public void CmdRemoveBuff(int index)
    {
        buffs.RemoveAt(index);
        Debug.Log("버프 제거 완료");
    }
    [ClientRpc]
    public void RpcTextSetActive(Buffs buff, bool isStart)
    {
        if (isStart)
        {
            tempBuff.isFix = buff.isFix;
            tempBuff.buffDP += buff.buffDP;
            tempBuff.securityAttack += buff.securityAttack;

            if (tempBuff.buffDP != 0)
            {
                DPbuffText.gameObject.SetActive(true);
                if(tempBuff.isFix)
                {
                    DPbuffText.text = "DP = " + tempBuff.buffDP.ToString();
                }
                else
                {
                    DPbuffText.text = "DP + " + tempBuff.buffDP.ToString();
                }
            }
            
            if (tempBuff.securityAttack > 0)
            {
                SecurityCheckText.gameObject.SetActive(true);
                SecurityCheckText.text = "S.C. + " + tempBuff.securityAttack.ToString();
            }

            if(tempBuff.waitTurn > 0)
            {
                isRestText.gameObject.SetActive(true);
                isRestText.text = "레스트";
            }
        }

        else
        {
            tempBuff.buffDP -= buff.buffDP;
            tempBuff.securityAttack = 0;
            
            DPbuffText.gameObject.SetActive(false);
            SecurityCheckText.gameObject.SetActive(false);
            isRestText.gameObject.SetActive(false);
        }
    }

    [Command(requiresAuthority = false)]
    public void CmdRemoveEvo(int Count/*, bool isAscending //나중에 오름차순,내림차순 부분삭제할때 쓰기*/)
    {
        if(Count == -1)
        {
            FieldCard fieldCard = this;

            if (fieldCard.isUnderMostCard && fieldCard.isUpperMostCard) { return; } //최상단겸 최하단(단 한장)이면 리턴

            while(!fieldCard.isUnderMostCard)
            {
                //최하단 카드를 가져와서
                fieldCard = fieldCard.underCard;
            }
            while(!fieldCard.isUpperMostCard)
            {
                //무덤 보내기
                fieldCard.player.deck.graveyard.Add(fieldCard.card);
                //차례로 아래서부터 모두 파괴
                Destroy(fieldCard.gameObject);
                fieldCard = fieldCard.upperCard;
                fieldCard.underCard = null;
            }
            RpcRemoveEvoAfter(fieldCard);
        }
    }

    [ClientRpc]
    public void RpcRemoveEvoAfter(FieldCard fieldCard)
    {
        fieldCard.underCard = null;
        fieldCard.GetComponent<RectTransform>().anchoredPosition = Vector2.zero; //y축 정렬용 x축은 Update로 자동 정렬됨
    }
}